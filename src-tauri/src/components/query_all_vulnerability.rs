use rusqlite::{Connection, Result};
use serde::Serialize;
use std::fs;
use tauri::Manager;
use std::path::PathBuf;
use tauri::{command, AppHandle, Wry};

#[derive(Debug, Serialize)]
pub struct Vulnerability {
    pub id: i32,
    pub vuln_name: String,
    pub vuln_description: String,
    pub fix_suggestion: String,
    pub affects_type: String,
}

/// 统一获取数据库路径（开发直接读，打包复制到可写目录）
fn get_db_path(app_handle: &AppHandle<Wry>, db_name: &str) -> PathBuf {
    #[cfg(debug_assertions)]
        {
            let mut path = std::env::current_dir().expect("无法获取当前目录");
            path.push("resources");
            path.push(db_name);
            path
        }

    #[cfg(not(debug_assertions))]
    {
        // 生产: 直接从 app 的 Resources 读取
        let resource_dir = app_handle
            .path()
            .resource_dir()
            .expect("无法获取资源目录");

        let db_path = resource_dir.join(db_name);
        println!("[PROD] 使用数据库路径: {:?}", db_path);

        if !db_path.exists() {
            panic!("生产环境找不到数据库文件: {:?}", db_path);
        }

        return db_path;
    }
}

#[command]
pub fn query_all_vulnerability(app_handle: AppHandle) -> Result<Vec<Vulnerability>, String> {
    let db_path = get_db_path(&app_handle, "vulnerabilities.db");
    println!("查询所有漏洞 → 数据库路径: {:?}", db_path);

    // 必须是 mut 才能 transaction
    let mut conn = Connection::open(&db_path)
        .map_err(|e| format!("无法打开数据库: {}", e))?;

    let mut stmt = conn
        .prepare("SELECT id, vuln_name, vuln_description, fix_suggestion, affects_type FROM vulnerabilities")
        .map_err(|e| e.to_string())?;

    // 关键：先 collect 出来，stmt 的借用在这里就结束了
    let vulnerabilities = stmt
        .query_map([], |row| {
            Ok(Vulnerability {
                id: row.get(0)?,
                vuln_name: row.get(1)?,
                vuln_description: row.get(2)?,
                fix_suggestion: row.get(3)?,
                affects_type: row.get(4)?,
            })
        })
        .map_err(|e| e.to_string())?
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| e.to_string())?;

    Ok(vulnerabilities)
}

#[command]
pub fn search_vulnerability_by_name(
    app_handle: AppHandle,
    query: String,
) -> Result<Vec<Vulnerability>, String> {
    let db_path = get_db_path(&app_handle, "vulnerabilities.db");
    println!("搜索漏洞 '{}' → 数据库路径: {:?}", query, db_path);

    let mut conn = Connection::open(&db_path)
        .map_err(|e| format!("无法打开数据库: {}", e))?;

    let mut stmt = conn
        .prepare(
            "SELECT id, vuln_name, vuln_description, fix_suggestion, affects_type
             FROM vulnerabilities
             WHERE vuln_name LIKE ?1"
        )
        .map_err(|e| e.to_string())?;

    let like_query = format!("%{}%", query);

    let vulnerabilities = stmt
        .query_map([&like_query], |row| {
            Ok(Vulnerability {
                id: row.get(0)?,
                vuln_name: row.get(1)?,
                vuln_description: row.get(2)?,
                fix_suggestion: row.get(3)?,
                affects_type: row.get(4)?,
            })
        })
        .map_err(|e| e.to_string())?
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| e.to_string())?;

    Ok(vulnerabilities)
}