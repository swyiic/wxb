use rusqlite::{params, Connection, Result};
use std::path::PathBuf;
use tauri::Manager;
use std::fs;
use tauri::{command, AppHandle, Wry}; // 引入 Manager trait

/// 获取数据库文件的路径
fn get_db_path(app_handle: &AppHandle<Wry>, db_name: &str) -> PathBuf {
    #[cfg(debug_assertions)]
        {
            let mut path = std::env::current_dir().expect("无法获取当前目录");
            path.push("resources");
            path.push(db_name);
            path
        }

    #[cfg(not(debug_assertions))]
        {
            // 生产: 直接从 app 的 Resources 读取
            let resource_dir = app_handle
                .path()
                .resource_dir()
                .expect("无法获取资源目录");

            let db_path = resource_dir.join(db_name);
            println!("[PROD] 使用数据库路径: {:?}", db_path);

            if !db_path.exists() {
                panic!("生产环境找不到数据库文件: {:?}", db_path);
            }

            return db_path;
        }
}


#[command]
pub fn edit_vulnerability(
    id: i32,
    vuln_name: String,
    vuln_description: String,
    fix_suggestion: String,
    affects_type: String,
    app_handle: AppHandle<Wry>,
) -> Result<(), String> {
    // 获取数据库路径
    let db_path = get_db_path(&app_handle, "vulnerabilities.db");
    println!("完整的数据库路径: {:?}", db_path); // 输出完整的数据库路径

    // 打开数据库连接
    let mut conn = Connection::open(db_path).map_err(|e| format!("无法连接到数据库: {}", e))?;
    let tx = conn.transaction().map_err(|e| e.to_string())?;
    // 执行更新操作
    tx.execute(
        "UPDATE vulnerabilities SET vuln_name = ?, vuln_description = ?, fix_suggestion = ? , affects_type = ? WHERE id = ?",
        params![vuln_name, vuln_description, fix_suggestion, affects_type, id],
    ).map_err(|e| e.to_string())?;
    // 提交事务
    tx.commit().map_err(|e| format!("事务提交失败: {}", e))?;
    Ok(())
}
